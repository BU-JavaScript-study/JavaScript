# 2021.01.14 자바스크립트 스터디 발표 자료

### **1. 함수의 기본 인자(파라미터) 값 설정**

ES6 에서 나온 문법으로, 인자 값을 넣지 않을 시, 디폴트로 인자에 넣어지는 값을 설정할 수 있음.

- 디폴트인자 값 설정

```js
function printName(name = "Dave") {
  console.log(name);
}

printName();
printName("Alex");
```

### **2. 구조 분해 할당 (비구조화 할당) 문법**

- 이름만 보면 이해하기 어려운 구조 분해 할당은 배열이나 객체의 속성을 해체해서, 값을 개별 변수에 대입할 수 있게 하는 문법

**객체 구조 분해 할당**

```js
let data = {
  name: "Dave",
  age: 20,
};

let { age, name } = data; // 동일한 프로퍼티명을 써줘야, 해당 프로퍼티에 맞는 값이 대입됨

console.log(name, age);
```

![](./image/01_14_1.png)

- 프로퍼티명과 다른 변수명을 사용하고자 할 경우, 대입할 프로퍼티명:다른 변수명 의 형태로 써줘야 함

```js
let { name: myName, age: myAge } = data;

console.log(myName, myAge);

// 꼭 객체의 모든 프로퍼티를 가져올 필요는 없고, 객체의 프로퍼티 중 가져오고 싶은 데이터만 가져올 수 있음
let { name: myName2 } = data;

console.log(myName2);
```

![](./image/01_14_2.png)

- 가져올 프로퍼티명을 다른 변수에 저장하되, 해당 프로퍼티명이 객체 안에 없을 경우, 다른 변수에 디폴트값을 대입하기

```js
let data = {
  name: "Dave",
  age: 20,
};

let { name, age: myAge = 25, hobby = "coding" } = data;

console.log(name, myAge, hobby);
```

![](./image/01_14_3.png)

**객체 구조 분해 할당**
배열의 각 아이템을 별도 변수에 할당하는 문법

```js
let myArray = [1, 2, 3, 4];
let [first, second, third, fourth] = myArray;

console.log(first, ssecond, third, fourth);

// 배열의 일부만 추출 가능, 첫번재 아이템부터 대입, 대입할 변수가 없을 경우는 대입하지 않음
let [data1, data2] = myArray;

console.log(data1, data2);

// 대입할 아이템이 없을 경우, undefined 로 대입
let myArray2 = [1, 2];
let [item1, item2, item3] = myArray2;

console.log(item1, item2, item3);

// 컴마를 통해, 필요하지 않은 아이템을 건너 띌 수 있음
let myArray3 = ["Dave", "David", "Alex"];
let [value, , value3] = myArray3;

console.log(value1, value3);
```

- ...을 통해, 나머지 요소를 한번에 가져올 수도 있음

```js
let myArray = ["Dave", "David", "Alex", "Jane", "Andy"];
let [item1, item2, ...item3] = myArray;

console.log(item1);
console.log(item2);
console.log(item3);
```

![](./image/01_14_4.png)

- 객체와 마찬가지로 기본값을 설정할 수도 있음

```js
let myArray = [10, 20];
let [item1, item2 = 10, item3 = 20] = myArray1;

console.log(item1, item2, item3);
```

### **3. 유용한 구조 분해 할당 문법 활용**

**변수값 교환하기**

```js
let a = 1;
let b = 2;

[a, b] = [b, a];

console.log(a, b);
```

**함수 리턴 시 여러 데이터 넘겨주기**

```js
function getData() {
  return [10, 20];
}

let [a, b] = getData();

console.log(a, b);
```

### **4. Rest 파라미터**

- Rest 파라미터는 함수 인자 선언 앞에 ...을 붙여서 정의하는 문법
- 해당 함수에 전달된 인자 리스트는 하나의 배열로 해당 변수에 넣어짐
- 인자의 수만틈 순차적으로 인작밧이 대입되고, 나머지만 배열로 대입
- ...변수는 함수의 맨 마지막에 나와야 함

```js
function getData(a, ...rest) {
  console.log(a);
  console.log(rest);
  console.log(Array.isArray(rest));
}

getData(10, 20, 30, 40, 50, 60);
```

### **5. Spread 파라미터**

- Rest 파라미터와 마찬가지로 ...을 붙여서 정의하는 문법
- iterable 변수 앞에 붙여서, 해당 변수의 데이터를 개별 아이템으로 분리함
  - iterable 이란 반복 가능한 객체를 의미하며, 배열, 문자열 등을 의미함

```js
let myArray = [1, 2, 3];

console.log(...myArray);
```

- 함수 인자에 맞추어, 배열의 각 아이템을 대입하고 싶을 경우

```js
function func(a, b, c) {
  console.log(a);
  console.log(b);
  console.log(c);
}

const data = [1, 2, 3];

func(...data);
```

- 기존 배열로 새로운 배열 구성하기

```js
const myArray1 = [1, 2, 3];
const myArray2 = [7, 8, ...myArray1, 4, 5, 6];

console.log(myArray2);
```

### **6. 동기적 처리와 비동기적 처리**

- Syncronous (동기) : 요청을 보낸 후, 해당 요청의 응답을 받아야 다음 동작을 실행 (코드를 한줄 실행 완료 후, 다음 줄 실행)

- Asynchronous (비동기) : 요청을 보낸 후, 응답과 관계없이 다음 동작을 실행 (코드를 한줄 실행 후, 완료와 상관없이 다음 줄 실행)

**비동기적 처리의 이해**

- 대부분의 프로그래밍 언어는 동기적 처리를 지향함
- 하지만, javascript의 경우는 실행이 오래 걸리는 동작의 경우, 이를 온전히 기다릴 필요 없이 다음 작업 실행이 가능하도록, 비동기적인 처리도 가능하도록 되어 있음.
- 따라서, javascript 는 다른 언어와 마찬가지로 동기적 처리가 기본이지만, 일부 기능은 비동기적으로 처리가 가능하도록 관련 기능을 추가로 제공하고 있다고 이해하면 좋음

**주요 비동기적 처리**

오래 걸리는 기능은 비동기적으로 처리됨

- Rest API 요청
- 파일/데이터베이스 처리
- 타이머, 암호화/복호화 등

```js
console.log("테스트 결과 입니다");
setTimeout(() => {
  console.log("테스트");
}, 3000);

console.log("sungkyu");
```

![](./image/01_14_5.png)

**비동기 처리의 문제점**

예를 들어, Rest API 를 호출해서 결과값을 받아서, 이를 기반으로 코드를 실행하는 경우를 생각해보기로 함

해당 함수 호출 후, 결과값을 받지 않은 채로, 다음 코드가 실행되면, 전체 코드 실행에 문제가 됨

### **7. 콜백함수(Callback Function)**

비동기 처리의 문제점을 해결할 수 있는 콜백함수

- 자바스크립트에서 함수는 first-class-function
  - 함수 자체를 변수에 저장 가능
  - 함수의 인자에 다른 함수를 인수로 전달 가능
  - 함수의 반환 값(return 값)으로 함수를 전달 가능

```js
function func1(callback) {
  setTimeout(() => {
    console.log("func1");
    callback();
  }, 1000);
}

function func2() {
  console.log("fun2");
}

func1(func2);
```

![](./image/01_14_6.png)

### **8. Promise**

ES6 에서 공식적으로 추가된 문법으로, 비동기 처리를 위한 콜백함수의 단점을 극복하기 위해 제안됨

1. new 로 Promise 객체 생성
2. Promise 객체에서는 executor 라는 함수가 자동으로 실행되고, executor 라는 함수는 resolve와 reject 라는 두 개의 함수를 인자로 받아서 비동기 처리 함수를 실행
3. executor 를 통해 비동기 처리 함수를 실행 완료 후, 해당 작업이 성공이면 resolve, 실패면 reject 함수를 호출

```js
const runCode = new Promise((resolve, reject) => {
  // 비동기 작업 수행
  setTimeout(() => {
    let num = 10;
    if (num >= 11) {
      // 비동기 작업 성공
      resolve(num);
    } else {
      // 비동기 작업 실패
      reject("error");
    }
  }, 1000);
});
```

**then 메서드**

위 코드에서 작업 성공 또는 실패시, 수행할 작업을 정의하고, promise 코드를 실행해주는 메서드

- 두 콜백 함수를 인자로 받음
  - successCallback : 작업 성공 시의 실행 함수
  - failureCallback : 작업 실패 시의 실행 함수

```js
runCode.then(successCallback, failureCallback);
```

```js
const runCode = new Promise((resolve, reject) => {
  // 비동기 작업 수행
  setTimeout(() => {
    let num = 10;
    if (num >= 11) {
      // 비동기 작업 성공
      resolve(num);
    } else {
      // 비동기 작업 실패
      reject("error");
    }
  }, 1000);
});

runCode.then(
  (num) => {
    console.log("success", num); // 성공 함수
  },
  (err) => {
    console.log(err); // 실패 함수
  }
);
```

```js
// Promise 객체 생성
const promise = new Promise((resolve, reject) => {
  // 비동기 작업 수행
  setTimeout(() => {
    let num = 10;
    if (num >= 11) {
      /* 비동기 작업 성공 */
      resolve(num);
    } else {
      /* 비동기 작업 실패 */
      reject("error");
    }
  }, 1000);
});

// 실행 순서에 맞춰줄 필요가 있을 경우, then 을 이어서 작성해줄 수 있음 (콜백지옥에서 해방됨)
promise
  .then((num) => {
    console.log("success", num);
  })
  .then(() => {
    console.log("success", num);
  });
```

**catch 메서드**

- 실행 중, 예외상황을 처리함
- failureCallback(실패 함수)가 정의되어 있지 않을 경우, reject 시에도 catch 메서드를 호출함

```js
// Promise 객체 생성
const promise = new Promise((resolve, reject) => {
  // 비동기 작업 수행
  setTimeout(() => {
    let num = 10;
    if (num >= 11) {
      /* 비동기 작업 성공 */
      resolve(num);
    } else {
      /* 비동기 작업 실패 */
      reject("this is an error");
    }
  }, 1000);
});

promise
  .then((num) => {
    console.log("success", num);
  })
  .catch((error) => {
    console.log(error);
  });
```

**참고: throw**

- 사용자 정의 예외를 던질 때 사용

  - catch 블록이 있으면 catch 블록으로 전달되고, 그렇지 않으면 프로그램을 종료함

- 보통 다음과 같은 구문으로 사용됨 (Error 클래스의 객체를 만들어서, 전달함)

```js
throw new Error("에러메세지");
```

```js
// Promise 객체 생성
const promise = new Promise((resolve, reject) => {
  console.log("start");
  resolve(1);
});

promise
  .then((num) => {
    console.log("success1");
  })
  .then((num) => {
    console.log("success2");
    throw new Error("error");
  })
  .then((num) => {
    console.log("success3"); // success3은 출력 X
  })
  .catch((err) => {
    console.log("error");
  });
```

![](./image/01_14_7.png)

- then 에서 return 값은 다음 then 의 인자로 넘겨진다.

```js
// Promise 객체 생성
const promise = new Promise((resolve, reject) => {
  // 비동기 작업 수행
  setTimeout(() => {
    let num = 10;
    if (num >= 9) {
      /* 비동기 작업 성공 */
      resolve(num);
    } else {
      /* 비동기 작업 실패 */
      reject("this is an error");
    }
  }, 500);
});

promise
  .then((num) => {
    console.log("success1", num);
    return 2; /* return 값이 다음 then 의 인자로 넘겨짐 */
  })
  .then((num) => {
    console.log("success2", num);
  });
```

![](./image/01_14_8.png)

**finally**

finally() 는 Promise 가 resolve 되는 reject 되는 마지막에 해당 함수를 실행함

```js
// Promise 객체 생성
const promise = new Promise((resolve, reject) => {
  // 비동기 작업 수행
  setTimeout(() => {
    let num = 10;
    if (num >= 9) {
      /* 비동기 작업 성공 */
      resolve(num);
    } else {
      /* 비동기 작업 실패 */
      reject("this is an error");
    }
  }, 500);
});

promise
  .then((num) => {
    console.log("success1", num);
    return 2; /* return 값이 다음 then 의 인자로 넘겨짐 */
  })
  .then((num) => {
    console.log("success2", num);
  })
  .finally(() => {
    console.log("finally");
  });
```

**Promise.all**

- 동기화 처리할 Promise를 묶어서 한번에 실행
- 즉 여러 함수가 다 실행이 완료된 후에, then 구문을 실행함

```js
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => resolve("100ms"), 100);
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => resolve("500ms"), 500);
});

Promise.all([promise1, promise2]).then((data) => {
  console.log(data);
});
```

**Promise.race**

- 여러 함수 중, 제일 빠르게 실행완료된 함수만 then 구문을 실행함

```js
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => resolve("100ms"), 100);
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => resolve("500ms"), 500);
});

Promise.race([promise1, promise2]).then((data) => {
  console.log(data);
});
```
